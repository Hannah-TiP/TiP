name: TIP Customer Frontend CI/CD

on:
  push:
    branches:
      - develop  # Auto-deploy to preview
      - main     # Auto-deploy to production
  pull_request:
    branches: [develop, main]
    types: [opened, synchronize, reopened]
  workflow_dispatch:  # Manual trigger for production or preview
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'preview'
        type: choice
        options:
          - preview
          - production

env:
  NODE_VERSION: 20

jobs:
  test-and-build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install Dependencies
        run: |
          npm ci

      - name: Run Linting
        run: |
          echo "ðŸ” Running ESLint..."
          npm run lint || {
            echo "âš ï¸ ESLint found some issues (not failing build)"
            echo "â„¹ï¸ Please review and fix linting issues in future commits"
            exit 0
          }

      - name: Build Application
        run: |
          echo "ðŸ”¨ Building Next.js application..."
          npm run build
          echo "âœ… Build completed successfully"

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts-${{ github.sha }}
          path: |
            .next/
            public/
          retention-days: 7

  build-and-push-docker:
    runs-on: ubuntu-latest
    needs: [test-and-build]
    # Build Docker on develop/main branch push or manual dispatch
    if: ((github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main') && github.event_name == 'push') || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read
      packages: write
    outputs:
      short_sha: ${{ steps.vars.outputs.short_sha }}
      registry: ${{ steps.vars.outputs.registry }}
      username: ${{ steps.vars.outputs.username }}
      image_base: ${{ steps.vars.outputs.image_base }}
      tag_versioned: ${{ steps.vars.outputs.tag_versioned }}
      tag_latest: ${{ steps.vars.outputs.tag_latest }}
      environment: ${{ steps.vars.outputs.environment }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare Docker Tags
        id: vars
        run: |
          # Extract short SHA
          SHORT_SHA=${GITHUB_SHA::8}
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

          # Use GitHub Container Registry
          REGISTRY="ghcr.io"
          # Convert repository owner to lowercase (required for ghcr.io)
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')

          # Determine environment tag
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV_TAG="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENV_TAG="production"
          elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
            ENV_TAG="preview"
          else
            ENV_TAG="preview"
          fi

          # Build image tags
          IMAGE_BASE="$REGISTRY/$REPO_OWNER/tip-customer"
          TAG_VERSIONED="$IMAGE_BASE:$ENV_TAG-$SHORT_SHA"
          TAG_LATEST="$IMAGE_BASE:$ENV_TAG-latest"

          echo "registry=$REGISTRY" >> $GITHUB_OUTPUT
          echo "username=$REPO_OWNER" >> $GITHUB_OUTPUT
          echo "image_base=$IMAGE_BASE" >> $GITHUB_OUTPUT
          echo "tag_versioned=$TAG_VERSIONED" >> $GITHUB_OUTPUT
          echo "tag_latest=$TAG_LATEST" >> $GITHUB_OUTPUT
          echo "environment=$ENV_TAG" >> $GITHUB_OUTPUT

          echo "ðŸ³ Docker tags prepared:"
          echo "  Registry: GitHub Container Registry (ghcr.io)"
          echo "  Repository: $REPO_OWNER/tip-customer"
          echo "  Environment: $ENV_TAG"
          echo "  Versioned tag: $TAG_VERSIONED"
          echo "  Latest tag: $TAG_LATEST"

      - name: Decrypt environment config
        run: |
          ENV="${{ steps.vars.outputs.environment }}"
          gpg --quiet --batch --yes \
            --decrypt \
            --passphrase="${{ secrets.ENV_PASSPHRASE }}" \
            "secrets/env.tip.${ENV}.gpg" > /tmp/env.${ENV}

      - name: Extract build args
        id: build-env
        run: |
          ENV="${{ steps.vars.outputs.environment }}"
          set -a; source /tmp/env.${ENV}; set +a
          echo "s3_endpoint=${NEXT_PUBLIC_S3_ENDPOINT}" >> $GITHUB_OUTPUT
          echo "api_base_url=${NEXT_PUBLIC_API_BASE_URL}" >> $GITHUB_OUTPUT
          echo "gmaps_key=${NEXT_PUBLIC_GOOGLE_MAPS_API_KEY}" >> $GITHUB_OUTPUT
          echo "gmaps_map_id=${NEXT_PUBLIC_GOOGLE_MAPS_MAP_ID}" >> $GITHUB_OUTPUT

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: |
            ${{ steps.vars.outputs.tag_versioned }}
            ${{ steps.vars.outputs.tag_latest }}
          cache-from: type=registry,ref=${{ steps.vars.outputs.tag_latest }}
          cache-to: type=inline
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.vars.outputs.environment }}-${{ steps.vars.outputs.short_sha }}
            NEXT_PUBLIC_S3_ENDPOINT=${{ steps.build-env.outputs.s3_endpoint }}
            NEXT_PUBLIC_API_BASE_URL=${{ steps.build-env.outputs.api_base_url }}
            NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=${{ steps.build-env.outputs.gmaps_key }}
            NEXT_PUBLIC_GOOGLE_MAPS_MAP_ID=${{ steps.build-env.outputs.gmaps_map_id }}

  deploy-preview:
    runs-on: ubuntu-latest
    needs: [build-and-push-docker]
    # Only auto-deploy preview
    if: needs.build-and-push-docker.outputs.environment == 'preview'
    environment: preview
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Upload preview env to server
        run: |
          gpg --quiet --batch --yes \
            --decrypt \
            --passphrase="${{ secrets.ENV_PASSPHRASE }}" \
            secrets/env.tip.preview.gpg | \
          ssh -i ~/.ssh/deploy_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} \
            "cat > ~/.env.tip.preview && chmod 600 ~/.env.tip.preview"

      - name: Deploy preview container
        run: |
          TAG="${{ needs.build-and-push-docker.outputs.tag_latest }}"
          GHCR_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          GHCR_USER="${{ github.actor }}"
          ssh -i ~/.ssh/deploy_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << ENDSSH
            echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USER}" --password-stdin
            docker pull ${TAG}
            docker logout ghcr.io
            docker stop tip-customer-preview || true
            docker rm tip-customer-preview || true
            docker run -d --name tip-customer-preview --restart unless-stopped \
              -p 9200:3000 --env-file ~/.env.tip.preview ${TAG}
            docker image prune -f
            echo "âœ… Preview deployed successfully"
            echo "ðŸŒ Available at: https://www.tip.zetos.io"
          ENDSSH

  deploy-production:
    runs-on: ubuntu-latest
    needs: [build-and-push-docker]
    # Auto-deploy to production
    if: needs.build-and-push-docker.outputs.environment == 'production'
    environment: production
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Upload production env to server
        run: |
          gpg --quiet --batch --yes \
            --decrypt \
            --passphrase="${{ secrets.ENV_PASSPHRASE }}" \
            secrets/env.tip.production.gpg | \
          ssh -i ~/.ssh/deploy_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} \
            "cat > ~/.env.tip.production && chmod 600 ~/.env.tip.production"

      - name: Get current production image
        id: prev-image
        run: |
          PREV_TAG=$(ssh -i ~/.ssh/deploy_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} \
            "docker ps --filter name=tip-customer-production --format '{{.Image}}'" 2>/dev/null || echo "")
          echo "tag=${PREV_TAG}" >> $GITHUB_OUTPUT

      - name: Deploy production container
        run: |
          TAG="${{ needs.build-and-push-docker.outputs.tag_latest }}"
          GHCR_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          GHCR_USER="${{ github.actor }}"
          ssh -i ~/.ssh/deploy_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << ENDSSH
            echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USER}" --password-stdin
            docker pull ${TAG}
            docker logout ghcr.io
            docker stop tip-customer-production || true
            docker rm tip-customer-production || true
            docker run -d --name tip-customer-production --restart unless-stopped \
              -p 9201:3000 --env-file ~/.env.tip.production ${TAG}
            docker image prune -f
          ENDSSH

      - name: Health check (12 Ã— 10s = 2min)
        run: |
          PREV_TAG="${{ steps.prev-image.outputs.tag }}"
          for i in $(seq 1 12); do
            if ssh -i ~/.ssh/deploy_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} \
              "curl -sf http://localhost:9201/api/health"; then
              echo "âœ… Health check passed"
              exit 0
            fi
            echo "â³ Attempt $i/12 â€” waiting 10s..."
            sleep 10
          done
          echo "âŒ Health check failed â€” rolling back to ${PREV_TAG:-previous image}"
          if [ -n "$PREV_TAG" ]; then
            ssh -i ~/.ssh/deploy_key ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << ENDSSH
              docker stop tip-customer-production || true
              docker rm tip-customer-production || true
              docker run -d --name tip-customer-production --restart unless-stopped \
                -p 9201:3000 --env-file ~/.env.tip.production $PREV_TAG
              echo "â®ï¸  Rolled back to $PREV_TAG"
            ENDSSH
          fi
          exit 1

  notification:
    runs-on: ubuntu-latest
    needs: [build-and-push-docker, deploy-preview, deploy-production]
    if: always()
    steps:
      - name: Send Deployment Notification
        run: |
          ENV="${{ needs.build-and-push-docker.outputs.environment }}"

          if [ "$ENV" == "preview" ]; then
            if [ "${{ needs.deploy-preview.result }}" == "success" ]; then
              echo "âœ… TIP Customer Frontend preview deployment successful"
              echo "ðŸŒ Live at: https://www.tip.zetos.io"
            else
              echo "âŒ TIP Customer Frontend preview deployment failed"
            fi
          elif [ "$ENV" == "production" ]; then
            if [ "${{ needs.deploy-production.result }}" == "success" ]; then
              echo "âœ… TIP Customer Frontend production deployment successful"
              echo "ðŸŒ Live at: https://www.travelinyourpocket.com"
            else
              echo "âŒ TIP Customer Frontend production deployment failed"
            fi
          fi
